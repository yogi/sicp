
Chapter 1
---------

Languages typically offer:
* primitive expressions
* means of combining
* means of abstraction: naming and manipulating compound things

variable: name that refers to a value
environment: memory that holds name-value associations

Substitution model of procedure application
Applicative-order evaluation: evaluate arguments and then apply
Normal-order evaluation: expand-fully then reduce
bound variable: one which can be renamed across all usages without changing the meaning of the procedure definition  
  procedures bind their formal parameters
free variable: one which is not bound
scope of variable: set of expressions for which a binding defines a name

block-structure: mechanism to reduce name conflicts by having nested-definitions with local-names

lexical scoping: free variables get the value from the environment in which the procedure was defined (not invoked) 


recursive procedure: procedure that calls itself

recursive process: builds up deferred work as it goes along
  requires an interpreter with a stack
  
iterative process: carries along all the state required for the computation 
  can be computed solely with registers
a recursive procedure can generate recursive or iterative processes
  tail recursion in scheme

linear recursive process
linear iterative process

golden ratio: n^2 = n + 1 =~ 1.6180

functions:
  linear - output difference is constant
  exponential - output ratio is constant
  
equations:
  polynomial - sum of terms of different degrees
  quadratic - second degree polynomial in one variable

  
Chapter 2
---------
Data abstraction: separating an abstract data type from concrete representation. The abstract data is is defined in terms of procedures that can create (constructors) and query (selectors) the data (note: there's no manipulation of data, is it all immutable?).

What is data? You could look at it as a set of procedures and conditions that hold amongst them e.g. cons, car, cdr can be implemented as procedures:
(define (cons x y)
  (lambda (m) (m x y)))

(define (car z)
  (z (lambda(p q) p)))

(define (cdr z)
  (z (lambda(p q) q)))


Closure property o cons: An operation for combining objects satisfies the closure property when the result of the operation can be combined using the same operation. "Closure" is derived from abstract algebra where a set of elements is said to be "closed" under an operation when the result of applying the operation to members of the set is part of the set.

This is powerful because it allows creation of hierarchical data objects. 

Similar in some ways to Composite design pattern, and the use of JMock fluent interfaces (Builder pattern?). 

List: is a sequence of pairs formed by nested conses

Alan Perlis: "In Pascal the plethora of declarable data structures induces a specialization within functions that inhibits and penalizes casual cooperation. It's better to have 100 functions operate on 1 data structure than 10 functions operating on 10 data structures."

Reminds me of the power of pipes and filters on unix and the file abstraction (data structure?).

It's surprising, even amazing, that Lisp's pairs and cons' closure property are the crux of powerful data structures like lists.


